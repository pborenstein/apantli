<!DOCTYPE html>
<html>
<head>
    <title>LLM Proxy Stats</title>
    <link rel="icon" href="/static/favicon.ico" sizes="32x32">
    <link rel="apple-touch-icon" href="/static/apple-touch-icon.png">
    <link rel="manifest" href="/static/site.webmanifest">
    <script>
        // Version marker to help debug caching issues
        window.APANTLI_VERSION = '2025-10-16-001';
    </script>
    <script defer src="/static/alpine-persist.min.js"></script>
    <script defer src="/static/alpine.min.js"></script>
    <style>
        :root {
            /* Light mode colors */
            --color-primary: #1890ff;
            --color-primary-dark: #096dd9;
            --color-primary-light: #40a9ff;

            /* Provider colors */
            --color-openai: #10a37f;
            --color-anthropic: #d97757;
            --color-google: #4285f4;
            --color-default: #999999;

            /* Semantic colors */
            --color-success: #52c41a;
            --color-warning: #faad14;
            --color-error: #f5222d;

            /* Neutrals - Light mode */
            --color-text: #262626;
            --color-text-secondary: #8c8c8c;
            --color-border: #d9d9d9;
            --color-background: #ffffff;
            --color-background-secondary: #fafafa;
            --color-background-tertiary: #f0f0f0;
            --color-hover: #f5f5f5;
            --color-shadow: rgba(0, 0, 0, 0.15);

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;

            /* Typography */
            --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
            --font-system: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        [data-theme="dark"] {
            /* Dark mode colors */
            --color-text: #e8e8e8;
            --color-text-secondary: #a8a8a8;
            --color-border: #404040;
            --color-background: #1a1a1a;
            --color-background-secondary: #242424;
            --color-background-tertiary: #2a2a2a;
            --color-hover: #2f2f2f;
            --color-shadow: rgba(0, 0, 0, 0.5);
        }

        * {
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
        }

        body {
            font-family: var(--font-mono);
            max-width: 1200px;
            margin: 40px auto;
            padding: 0 20px;
            background-color: var(--color-background);
            color: var(--color-text);
        }

        h1 {
            border-bottom: 2px solid var(--color-text);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h2 {
            margin-top: 30px;
            border-bottom: 1px solid var(--color-border);
            color: var(--color-text);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            text-align: left;
            padding: var(--spacing-sm);
            border-bottom: 1px solid var(--color-border);
        }

        th {
            background: var(--color-background-tertiary);
            color: var(--color-text);
        }

        .metric {
            display: inline-block;
            margin: 10px 20px 10px 0;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--color-text);
        }

        .metric-label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .error {
            color: var(--color-error);
        }

        .request-row {
            cursor: pointer;
        }

        .request-row:hover {
            background: var(--color-hover);
        }

        .request-detail {
            padding: 10px;
            background: var(--color-background-secondary);
        }

        /* Enhanced request detail styles */
        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--color-border);
        }

        .detail-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .detail-stat {
            font-size: 12px;
        }

        .detail-stat-label {
            color: var(--color-text-secondary);
        }

        .detail-stat-value {
            font-weight: bold;
            color: var(--color-text);
        }

        .detail-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .toggle-btn {
            padding: 4px 12px;
            border: 1px solid var(--color-border);
            background: var(--color-background);
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--color-text);
        }

        .toggle-btn:hover {
            background: var(--color-hover);
        }

        .toggle-btn.active {
            background: var(--color-text);
            color: var(--color-background);
        }

        .conversation-view {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            display: flex;
            gap: 10px;
            padding: 12px;
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: 4px;
        }

        .message-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .message-content {
            flex: 1;
            min-width: 0;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .message-role {
            font-weight: bold;
            color: var(--color-text);
        }

        .message-meta {
            font-size: 11px;
            color: var(--color-text-secondary);
        }

        .message-text {
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
            color: var(--color-text);
        }

        .copy-btn {
            padding: 2px 8px;
            border: 1px solid var(--color-border);
            background: var(--color-background-secondary);
            border-radius: 3px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--color-text);
        }

        .copy-btn:hover {
            background: var(--color-hover);
        }

        .copy-btn:active {
            background: var(--color-success);
            color: white;
        }

        /* Code highlighting */
        .message-text pre {
            background: var(--color-background-tertiary);
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 8px 0;
        }

        .message-text code {
            font-family: var(--font-mono);
            font-size: 12px;
        }

        .message-text :not(pre) > code {
            background: var(--color-background-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
        }

        .json-view {
            font-size: 11px;
            overflow-x: auto;
            margin: 5px 0;
        }

        .json-tree {
            font-family: var(--font-mono);
            line-height: 1.4;
        }

        .json-key { color: #881391; }
        .json-string { color: #1A1AA6; }
        .json-number { color: #1C00CF; }
        .json-boolean { color: #0D22AA; }
        .json-null { color: #808080; }

        [data-theme="dark"] .json-key { color: #c678dd; }
        [data-theme="dark"] .json-string { color: #98c379; }
        [data-theme="dark"] .json-number { color: #d19a66; }
        [data-theme="dark"] .json-boolean { color: #61afef; }
        [data-theme="dark"] .json-null { color: #888888; }

        .json-toggle {
            cursor: pointer;
            user-select: none;
            display: inline-block;
            width: 12px;
        }

        .json-toggle:hover {
            background: var(--color-hover);
        }

        .json-line {
            margin-left: 20px;
        }

        .json-collapsed {
            display: none;
        }

        nav {
            margin: 20px 0;
            border-bottom: 1px solid var(--color-border);
        }

        nav a {
            display: inline-block;
            padding: 10px 20px;
            text-decoration: none;
            color: var(--color-text);
        }

        nav a.active {
            border-bottom: 2px solid var(--color-text);
            font-weight: bold;
        }

        /* Theme toggle button */
        .theme-toggle {
            background: var(--color-background-secondary);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 14px;
            color: var(--color-text);
        }

        .theme-toggle:hover {
            background: var(--color-hover);
        }

        /* Calendar styles */
        .calendar-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .calendar-header button {
            padding: 8px 16px;
            font-size: 18px;
            cursor: pointer;
            border: 1px solid var(--color-border);
            background: var(--color-background-secondary);
            color: var(--color-text);
            border-radius: 4px;
        }

        .calendar-header button:hover {
            background: var(--color-hover);
        }

        .calendar-header h2 {
            margin: 0;
            min-width: 200px;
            text-align: center;
            color: var(--color-text);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin: 20px 0;
        }

        .calendar-day-header {
            padding: 10px;
            text-align: center;
            font-weight: bold;
            background: var(--color-background-tertiary);
            border: 1px solid var(--color-border);
            color: var(--color-text);
        }

        .calendar-day {
            aspect-ratio: 1;
            padding: 8px;
            border: 1px solid var(--color-border);
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 80px;
        }

        .calendar-day:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px var(--color-shadow);
        }

        .calendar-day.today {
            border: 2px solid var(--color-primary);
        }

        .calendar-day.empty {
            background: var(--color-background-secondary);
            cursor: default;
        }

        .calendar-day.empty:hover {
            transform: none;
            box-shadow: none;
        }

        .day-number {
            font-size: 14px;
            font-weight: bold;
            color: var(--color-text);
        }

        .day-cost {
            font-size: 12px;
            font-weight: bold;
            color: var(--color-text);
            margin: 4px 0;
        }

        .day-requests {
            font-size: 10px;
            color: var(--color-text-secondary);
        }

        #day-detail {
            margin-top: 30px;
            padding: 20px;
            background: var(--color-background-secondary);
            border: 1px solid var(--color-border);
            border-radius: 4px;
        }

        #day-detail h3 {
            margin-top: 0;
            color: var(--color-text);
        }

        .provider-bar {
            margin: 15px 0;
        }

        .provider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--color-text);
        }

        .bar-container {
            height: 24px;
            background: var(--color-background-tertiary);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .bar-segment {
            height: 100%;
            transition: width 0.3s ease;
        }

        .provider-details {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-top: 4px;
        }

        /* Provider trends chart styles */
        #provider-trends-chart {
            margin: 20px 0;
            padding: 20px;
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: 4px;
        }

        .chart-svg {
            width: 100%;
            height: 300px;
            overflow: visible;
        }

        .chart-line {
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .chart-dot {
            fill: var(--color-background);
            stroke-width: 2;
            cursor: pointer;
        }

        .chart-dot:hover {
            r: 5;
        }

        .chart-axis {
            stroke: var(--color-border);
            stroke-width: 1;
        }

        .chart-axis-text {
            fill: var(--color-text-secondary);
            font-size: 11px;
            font-family: var(--font-mono);
        }

        .chart-grid {
            stroke: var(--color-border);
            stroke-width: 1;
            opacity: 0.3;
        }

        .chart-legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .chart-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .chart-legend-item:hover {
            background: var(--color-hover);
        }

        .chart-legend-item.inactive {
            opacity: 0.3;
        }

        .chart-legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .chart-legend-label {
            font-size: 12px;
            color: var(--color-text);
            font-family: var(--font-mono);
        }

        .chart-tooltip {
            position: absolute;
            background: var(--color-background-secondary);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            pointer-events: none;
            box-shadow: 0 2px 8px var(--color-shadow);
            z-index: 1000;
            display: none;
        }

        .chart-tooltip-date {
            font-weight: bold;
            margin-bottom: 4px;
            color: var(--color-text);
        }

        .chart-tooltip-item {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            color: var(--color-text);
        }

        .chart-empty {
            text-align: center;
            padding: 40px;
            color: var(--color-text-secondary);
        }

        .chart-empty p {
            margin: 10px 0;
        }

        .chart-empty-hint {
            font-size: 0.9em;
            opacity: 0.7;
        }

        .chart-bar {
            transition: opacity 0.2s;
        }

        .chart-bar:hover {
            opacity: 0.8;
        }

        .chart-title {
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--color-text);
        }

        .chart-legend-text {
            fill: var(--color-text);
            font-size: 12px;
        }

        /* Model efficiency styles */
        .efficiency-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .efficiency-card {
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 15px;
            transition: border-color 0.2s;
        }

        .efficiency-card:hover {
            border-color: var(--color-primary);
        }

        .efficiency-card.highlight-economical {
            border-color: #52c41a;
            background: color-mix(in srgb, #52c41a 5%, var(--color-background));
        }

        .efficiency-card.highlight-tokens {
            border-color: #1890ff;
            background: color-mix(in srgb, #1890ff 5%, var(--color-background));
        }

        .efficiency-model-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--color-text);
        }

        .efficiency-badge {
            display: inline-block;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 6px;
            font-weight: normal;
        }

        .efficiency-badge.economical {
            background: #52c41a;
            color: white;
        }

        .efficiency-badge.token-rich {
            background: #1890ff;
            color: white;
        }

        .efficiency-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 12px;
        }

        .efficiency-metric {
            display: flex;
            flex-direction: column;
        }

        .efficiency-metric-label {
            color: var(--color-text-secondary);
            font-size: 11px;
            margin-bottom: 2px;
        }

        .efficiency-metric-value {
            color: var(--color-text);
            font-weight: bold;
            font-family: var(--font-mono);
        }

        .efficiency-summary {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--color-border);
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        /* Date filter styles */
        .date-filter {
            background: var(--color-background-secondary);
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            border: 1px solid var(--color-border);
        }

        .filter-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .filter-btn {
            padding: 6px 12px;
            border: 1px solid var(--color-border);
            background: var(--color-background);
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 13px;
            color: var(--color-text);
        }

        .filter-btn:hover {
            background: var(--color-hover);
        }

        .filter-btn.active {
            background: var(--color-text);
            color: var(--color-background);
            border-color: var(--color-text);
        }

        .filter-custom {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-custom input[type="date"] {
            padding: 6px 8px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 13px;
            background: var(--color-background);
            color: var(--color-text);
        }

        .filter-custom span {
            color: var(--color-text-secondary);
            font-size: 13px;
        }

        /* Request filter styles */
        .request-filters {
            background: var(--color-background-secondary);
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            border: 1px solid var(--color-border);
        }

        .filter-row {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-row:last-child {
            margin-bottom: 0;
        }

        .filter-search {
            flex: 1;
            min-width: 300px;
        }

        .filter-search label {
            display: block;
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-bottom: 4px;
        }

        .filter-search input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-family: var(--font-mono);
            background: var(--color-background);
            color: var(--color-text);
        }

        .filter-select {
            flex: 1;
            min-width: 150px;
        }

        .filter-select label {
            display: block;
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-bottom: 4px;
        }

        .filter-select select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-family: var(--font-mono);
            background: var(--color-background);
            color: var(--color-text);
        }

        .filter-cost-range {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .filter-cost-range label {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .filter-cost-range input {
            width: 90px;
            padding: 6px 8px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            font-family: var(--font-mono);
            background: var(--color-background);
            color: var(--color-text);
        }

        .filter-cost-range span {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        /* Request summary styles */
        .request-summary {
            display: flex;
            gap: 20px;
            padding: 15px;
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: 4px;
            margin: 20px 0;
        }

        .summary-metric {
            text-align: center;
        }

        .summary-metric .metric-value {
            display: block;
            font-size: 20px;
            font-weight: bold;
            color: var(--color-text);
        }

        .summary-metric .metric-label {
            display: block;
            font-size: 11px;
            color: var(--color-text-secondary);
            margin-top: 4px;
        }

        /* Sortable table styles */
        th.sortable {
            cursor: pointer;
            user-select: none;
        }

        th.sortable:hover {
            background: var(--color-hover);
        }

        th.sortable::after {
            content: ' ⇅';
            color: var(--color-text-secondary);
            font-size: 10px;
        }

        th.sortable.sort-asc::after {
            content: ' ▲';
            color: var(--color-text);
        }

        th.sortable.sort-desc::after {
            content: ' ▼';
            color: var(--color-text);
        }

        /* Focus indicators */
        button:focus,
        input:focus,
        select:focus,
        a:focus,
        .calendar-day:focus {
            outline: 2px solid var(--color-primary);
            outline-offset: 2px;
        }

        button:focus:not(:focus-visible),
        input:focus:not(:focus-visible),
        select:focus:not(:focus-visible),
        a:focus:not(:focus-visible),
        .calendar-day:focus:not(:focus-visible) {
            outline: none;
        }

        /* Loading spinner */
        .loading-spinner {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            color: var(--color-text-secondary);
        }

        .spinner {
            border: 3px solid var(--color-border);
            border-top: 3px solid var(--color-primary);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error banner */
        .error-banner {
            display: none;
            padding: 15px;
            margin: 20px 0;
            background: var(--color-error);
            color: white;
            border-radius: 4px;
            font-weight: bold;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                margin: 10px;
                padding: 0 10px;
            }

            .metric {
                display: block;
                margin: 10px 0;
            }

            table {
                font-size: 12px;
            }

            th, td {
                padding: 4px;
            }

            .calendar-grid {
                gap: 1px;
            }

            .calendar-day {
                padding: 4px;
                min-height: 60px;
            }

            .day-cost {
                font-size: 10px;
            }

            .day-requests {
                font-size: 8px;
            }

            .filter-buttons {
                flex-direction: column;
            }

            .filter-btn {
                width: 100%;
            }

            .filter-custom {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-row {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-search,
            .filter-select {
                min-width: 100%;
            }

            .request-summary {
                flex-direction: column;
                gap: 10px;
            }

            h1 {
                flex-direction: column;
                gap: 10px;
            }
        }

        .pagination {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
            padding: 10px;
            background: var(--color-background-secondary);
            border-radius: 4px;
        }

        .pagination button {
            padding: 8px 16px;
            cursor: pointer;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 4px;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body x-data="{
    currentTab: $persist('stats'),
    theme: $persist('light'),
    dateFilter: $persist({
        startDate: '',
        endDate: ''
    }),
    dbDateRange: { startDate: null, endDate: null },
    currentPage: 1,
    itemsPerPage: 50,
    totalItems: 0,
    requestFilters: $persist({
        provider: '',
        model: '',
        minCost: '',
        maxCost: '',
        search: ''
    }),

    toggleTheme() {
        this.theme = this.theme === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', this.theme);
    },

    formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    },

    // Set filter to quick range
    async setQuickFilter(filter, range) {
        const today = new Date();

        switch(range) {
            case 'all':
                // Clear filter to show all requests
                filter.startDate = '';
                filter.endDate = '';
                // Still fetch DB range for display purposes
                try {
                    const res = await fetch('/stats/date-range');
                    const data = await res.json();
                    if (data.start_date && data.end_date) {
                        this.dbDateRange.startDate = data.start_date;
                        this.dbDateRange.endDate = data.end_date;
                    }
                } catch (e) {
                    // Ignore errors
                }
                break;
            case 'today':
                filter.startDate = filter.endDate = this.formatDate(today);
                break;
            case 'yesterday':
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                filter.startDate = filter.endDate = this.formatDate(yesterday);
                break;
            case 'this-week':
                const weekStart = new Date(today);
                weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 6);
                filter.startDate = this.formatDate(weekStart);
                filter.endDate = this.formatDate(weekEnd);
                break;
            case 'this-month':
                const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
                const monthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
                filter.startDate = this.formatDate(monthStart);
                filter.endDate = this.formatDate(monthEnd);
                break;
            case 'last-30-days':
                const thirtyDaysAgo = new Date(today);
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                filter.startDate = this.formatDate(thirtyDaysAgo);
                filter.endDate = this.formatDate(today);
                break;
        }
    },

    // Check if filter matches a quick range
    isQuickActive(filter, range) {
        if (range === 'all') {
            // Check if it matches the database range or is empty
            return (!filter.startDate && !filter.endDate) ||
                   (this.dbDateRange.startDate &&
                    filter.startDate === this.dbDateRange.startDate &&
                    filter.endDate === this.dbDateRange.endDate);
        }

        const temp = { startDate: '', endDate: '' };
        this.setQuickFilter(temp, range);
        return filter.startDate === temp.startDate && filter.endDate === temp.endDate;
    },

    // Build query string from filter
    buildQuery(filter) {
        const timezoneOffset = -new Date().getTimezoneOffset();
        let query = `?timezone_offset=${timezoneOffset}`;

        if (filter.startDate && filter.endDate) {
            query += `&start_date=${filter.startDate}&end_date=${filter.endDate}`;
        }
        return query;
    }
}" x-init="
    // Set initial theme
    document.documentElement.setAttribute('data-theme', theme);
    $watch('currentTab', value => onTabChange(value));
    $watch('theme', value => {
        // Reload calendar when theme changes to update colors
        if (currentTab === 'calendar') {
            loadCalendar();
        }
    });
    $watch('dateFilter', value => {
        refreshStats();
        currentPage = 1; // Reset to first page when date filter changes
        loadRequests();
    }, { deep: true });
    $watch('requestFilters', value => {
        currentPage = 1; // Reset to page 1 when filters change
        loadRequests();
    }, { deep: true });
    $watch('currentPage', value => loadRequests());
">
    <h1>
        <span>LLM Proxy Statistics</span>
        <button class="theme-toggle" @click="toggleTheme()" :aria-label="theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode'">
            <span x-show="theme === 'light'">Dark Mode</span>
            <span x-show="theme === 'dark'">Light Mode</span>
        </button>
    </h1>

    <div id="error-banner" class="error-banner" role="alert"></div>
    <div id="chart-tooltip" class="chart-tooltip"></div>

    <nav>
        <a href="#" :class="{ 'active': currentTab === 'stats' }" @click.prevent="currentTab = 'stats'">Stats</a>
        <a href="#" :class="{ 'active': currentTab === 'calendar' }" @click.prevent="currentTab = 'calendar'">Calendar</a>
        <a href="#" :class="{ 'active': currentTab === 'models' }" @click.prevent="currentTab = 'models'">Models</a>
        <a href="#" :class="{ 'active': currentTab === 'requests' }" @click.prevent="currentTab = 'requests'">Requests</a>
    </nav>

    <div id="stats-tab" x-show="currentTab === 'stats'">
        <div class="date-filter">
            <div class="filter-buttons">
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'all') }" @click="setQuickFilter(dateFilter, 'all')">All Time</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'today') }" @click="setQuickFilter(dateFilter, 'today')">Today</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'yesterday') }" @click="setQuickFilter(dateFilter, 'yesterday')">Yesterday</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'this-week') }" @click="setQuickFilter(dateFilter, 'this-week')">This Week</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'this-month') }" @click="setQuickFilter(dateFilter, 'this-month')">This Month</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'last-30-days') }" @click="setQuickFilter(dateFilter, 'last-30-days')">Last 30 Days</button>
            </div>

            <div class="filter-custom">
                <input type="date" x-model="dateFilter.startDate">
                <span>to</span>
                <input type="date" x-model="dateFilter.endDate">
                <button @click="dateFilter = { startDate: '', endDate: '' }" style="margin-left: 10px; padding: 4px 8px; border: 1px solid var(--color-border); background: var(--color-background); color: var(--color-text); cursor: pointer;">Clear Filter</button>
            </div>
            <div style="font-size: 12px; color: var(--color-text-secondary); margin-top: 8px;" x-show="dateFilter.startDate || dateFilter.endDate">
                Active filter: <span x-text="dateFilter.startDate || '(none)'"></span> to <span x-text="dateFilter.endDate || '(none)'"></span>
            </div>
        </div>

        <div id="totals"></div>

        <h2>Provider Cost Breakdown</h2>
        <div id="provider-breakdown"></div>

        <h2>Provider Cost Trends</h2>
        <div id="provider-trends-chart"></div>

        <h2>By Model</h2>
        <table id="by-model"></table>

        <h2>Model Efficiency</h2>
        <div id="model-efficiency"></div>

        <h2>Model Performance (Speed)</h2>
        <div id="model-performance"></div>

        <h2>By Provider</h2>
        <table id="by-provider"></table>

        <h2>Recent Errors <button onclick="clearErrors()" style="margin-left: 10px;">Clear Errors</button></h2>
        <table id="errors"></table>
    </div>

    <div id="calendar-tab" x-show="currentTab === 'calendar'">
        <div class="calendar-header">
            <button id="prev-month" onclick="navigateMonth(-1)" aria-label="Previous month">←</button>
            <h2 id="current-month"></h2>
            <button id="next-month" onclick="navigateMonth(1)" aria-label="Next month">→</button>
        </div>
        <div class="calendar-grid" id="calendar-grid" role="grid" aria-label="Monthly calendar"></div>
        <div id="day-detail" style="display:none" role="region" aria-live="polite">
            <h3 id="day-detail-title"></h3>
            <div id="day-detail-content"></div>
        </div>
    </div>

    <div id="models-tab" x-show="currentTab === 'models'">
        <h2>Available Models</h2>
        <table id="models-list"></table>
    </div>

    <div id="requests-tab" x-show="currentTab === 'requests'">
        <div class="date-filter">
            <div class="filter-buttons">
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'all') }" @click="setQuickFilter(dateFilter, 'all')">All Time</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'today') }" @click="setQuickFilter(dateFilter, 'today')">Today</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'yesterday') }" @click="setQuickFilter(dateFilter, 'yesterday')">Yesterday</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'this-week') }" @click="setQuickFilter(dateFilter, 'this-week')">This Week</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'this-month') }" @click="setQuickFilter(dateFilter, 'this-month')">This Month</button>
                <button class="filter-btn" :class="{ 'active': isQuickActive(dateFilter, 'last-30-days') }" @click="setQuickFilter(dateFilter, 'last-30-days')">Last 30 Days</button>
            </div>

            <div class="filter-custom">
                <input type="date" x-model="dateFilter.startDate">
                <span>to</span>
                <input type="date" x-model="dateFilter.endDate">
                <button @click="dateFilter = { startDate: '', endDate: '' }" style="margin-left: 10px; padding: 4px 8px; border: 1px solid var(--color-border); background: var(--color-background); color: var(--color-text); cursor: pointer;">Clear Filter</button>
            </div>
            <div style="font-size: 12px; color: var(--color-text-secondary); margin-top: 8px;" x-show="dateFilter.startDate || dateFilter.endDate">
                Active filter: <span x-text="dateFilter.startDate || '(none)'"></span> to <span x-text="dateFilter.endDate || '(none)'"></span>
            </div>
        </div>

        <div class="request-filters">
            <div class="filter-row">
                <div class="filter-search">
                    <label for="search-requests">Search:</label>
                    <input type="text" id="search-requests" placeholder="Search in model or content..." x-model="requestFilters.search">
                </div>
            </div>

            <div class="filter-row">
                <div class="filter-select">
                    <label for="filter-provider">Provider:</label>
                    <select id="filter-provider" x-model="requestFilters.provider">
                        <option value="">All</option>
                    </select>
                </div>

                <div class="filter-select">
                    <label for="filter-model">Model:</label>
                    <select id="filter-model" x-model="requestFilters.model">
                        <option value="">All</option>
                    </select>
                </div>

                <div class="filter-cost-range">
                    <label>Cost Range:</label>
                    <input type="number" id="min-cost" placeholder="Min $" step="0.0001" min="0" x-model.number="requestFilters.minCost">
                    <span>to</span>
                    <input type="number" id="max-cost" placeholder="Max $" step="0.0001" min="0" x-model.number="requestFilters.maxCost">
                </div>
            </div>
        </div>

        <div id="request-summary" style="display: none;" class="request-summary">
            <div class="summary-metric">
                <span class="metric-value" id="summary-count">0</span>
                <span class="metric-label">Requests</span>
            </div>
            <div class="summary-metric">
                <span class="metric-value" id="summary-cost">$0.00</span>
                <span class="metric-label">Total Cost</span>
            </div>
            <div class="summary-metric">
                <span class="metric-value" id="summary-tokens">0</span>
                <span class="metric-label">Tokens</span>
            </div>
            <div class="summary-metric">
                <span class="metric-value" id="summary-avg-cost">$0.00</span>
                <span class="metric-label">Avg Cost</span>
            </div>
        </div>

        <h2>Recent Requests</h2>
        <table id="requests-list"></table>

        <div class="pagination" x-show="totalItems > itemsPerPage">
            <button @click="currentPage = Math.max(1, currentPage - 1)" :disabled="currentPage === 1">Previous</button>
            <span>Page <span x-text="currentPage"></span> of <span x-text="Math.ceil(totalItems / itemsPerPage)"></span></span>
            <button @click="currentPage = Math.min(Math.ceil(totalItems / itemsPerPage), currentPage + 1)" :disabled="currentPage >= Math.ceil(totalItems / itemsPerPage)">Next</button>
            <span style="margin-left: 20px">Showing <span x-text="Math.min(itemsPerPage, totalItems - (currentPage - 1) * itemsPerPage)"></span> of <span x-text="totalItems"></span> requests</span>
        </div>
    </div>

    <footer style="text-align: center; padding: 2rem 1rem; margin-top: 3rem; border-top: 1px solid var(--border-color); font-size: 0.9rem; color: var(--text-secondary);">
        <a href="https://apantli.app" style="color: var(--text-primary); text-decoration: none;">apantli</a>
        &copy; 2025
        <a href="https://pborenstein.dev" style="color: var(--text-primary); text-decoration: none;">Philip Borenstein</a>
        /
        Made in New England
        <svg style="display: inline-block; width: 20px; height: 12px; margin-left: 4px; vertical-align: middle;" viewBox="0 0 720 432" xmlns="http://www.w3.org/2000/svg">
            <rect fill="#BF0000" width="720" height="432"/>
            <rect fill="#FFFFFF" width="216" height="216"/>
            <path fill="#8B5C29" d="M114.15,170.029c0.014,5.968-0.477,11.827-0.515,17.716c-0.014,2.087,0.094,4.623,0.532,6.655c0.371,1.723,1.579,3.449,1.61,5.309c1.604,0.192,1.417,2.074,2.89,2.24c3.276,5.972-4.25,4.03-8.133,4.017c-2.596-0.009-5.317,0.471-7.708,0.374c-2.542-0.102-4.343-0.099-6.985,0.693c0.775-0.864,1.915-1.14,2.653-2.073c1.315-1.661,0.982-3.981,1.256-5.948c0.48-3.446,0.51-6.72,0.543-10.222c0.03-3.22,0.646-6.491,1.014-9.534c0.379-3.143,0.017-6.566,0.012-9.74"/>
            <path fill="#00A33D" d="M106.451,177.728c-0.659,0.771-2.116,2.905-3.317,2.956c-0.677,0.028-0.791-0.767-1.382-0.835c-1.293-0.15-2.95-0.131-4.254-0.084c-3.118,0.112-6.175,0.19-9.288-0.195c-5.419-0.671-9.691-0.84-14.821,1.004c-2.198,0.791-4.47,0.994-6.891,0.757c-2.634-0.257-5.513-0.324-8.1-0.917c-2.044-0.468-5.359-1.641-3.124-4.239c2.086-2.422,5.909-0.999,7.908-2.977c-5.916-0.576-11.514,1.969-17.245,1.207c-2.225-0.295-6.479-0.411-4.526-3.638c1.237-2.043,4.039-3.845,4.58-6.283c1.443-0.231,2.658-2.697,3.968-3.55c1.415-0.921,3.485-1.811,5.079-2.284c0.805-2.183-1.333-2.853-1.97-4.477c-0.942-2.404,1.583-3.115,2.159-5.085c0.276-0.067,0.552-0.133,0.829-0.197c0.064-0.276,0.129-0.554,0.196-0.83c0.945-0.081,2.306-1.621,2.98-2.273c0.959-0.927,3.269-2.896,3.555-3.886c-3.207,0.052-0.782-3.19,0.211-4.096c1.622-1.482,3.088-2.2,4.813-3.332c1.044-0.686,3.19-2.747,2.736-4.204c-0.56-1.798-3.338-1.085-4.04-2.892c-1.123-2.891,3.778-7.663,5.296-10.006c1.02-1.576,2.386-2.687,3.733-3.944c1.773-1.655,2.878-3.862,4.573-5.562c-3.283,0.325-6.411-0.641-9.504-0.528c-1.313-3.878,6.129-7.486,8.178-9.531c1.532-1.53,2.78-3.687,4.41-5.291c1.409-1.387,3.391-4.042,5.114-4.628c-2.75-0.049-5.117,2.07-7.951,1.488c-0.66-2.025,3.381-6.556,4.343-8.393c1.374-2.622,4.216-5.47,4.853-8.503c1.038-4.941-3.487-2.807-4.999-5.742c-1.485-2.881,4.017-4.102,4.961-5.451c0.809-1.155,0.862-3.811,0.021-4.947c-0.834-1.126-2.029-0.736-2.104-2.371c-0.132-2.932,3.591-5.725,4.49-8.142c0.585-1.572-0.176-3.076-0.337-4.579c-0.174-1.611,0.401-3.653,1.082-5.035c0.461-0.936,1.487-1.887,1.98-3.054c0.356-0.846,0.654-1.671,1.024-2.52c0.759-1.744,1.573-3.308,2.331-5.197c0.955-2.379,3.654-3.548,4.824-5.754c0.821-1.548,0.292-3.377,1.16-4.991c0.654-1.212,1.341-1.934,1.723-3.256c-0.185-0.106-0.278-0.277-0.284-0.515l4.106-3.592c0.703,1.062,0.862,2.783,1.405,3.979c0.49,1.08,0.988,2.156,1.548,3.204c0.768,1.439,1.522,2.849,2.084,4.2c1.38,3.323,2.236,6.437,3.909,9.645c0.758,1.453,1.75,2.673,2.355,4.079c0.779,1.809,0.788,3.547,1.253,5.419c0.43,1.733,1.391,3.207,1.798,4.881c0.417,1.71,2.248,4.455,2.006,6.087c-0.787,0.03-1.67,0.012-2.447,0.181c1.553,3.237,5.245,5.556,7.414,8.364c1.064,1.38,1.237,2.384,1.79,3.822c0.419,1.092,1.137,2.117,1.003,3.32c-0.06,0.541-0.567,1.026-0.594,1.754c-0.285,0.056-0.569,0.113-0.853,0.173c-0.58,1.76,0.959,3.569,1.704,5.048c1.098,2.178,0.684,2.021-0.389,4.066c-1.116,2.13-0.914,3.538-0.366,5.683c0.306,1.2,0.131,1.724,1.006,2.83c0.613,0.774,1.451,1.217,1.646,2.202c0.275,0.072,0.553,0.134,0.833,0.189c0.268,1.856,3.144,3.968,2.693,6.083c-0.533,2.495-3.82,1.715-0.563,4.817c2.303,2.195,8.194,5.46,7.652,9.463c-2.047,0.115-3.539,1.29-5.513,1.193c0.25,1.777,3.247,2.755,4.385,4.131c1.618,1.956,2.957,4.649,5.307,5.831c2.662,1.338,11.009,4.133,4.625,7.38c-1.801,0.915-10.238,0.596-9.015,3.635c1.022,2.539,5.035,1.692,1.314,4.172c-2.718,1.812-4.869,1.769-8.094,2.18c0.958,1.79,4.134,4.129,5.709,4.846c1.166,0.532,2.744,0.302,4.004,0.662c3.18,0.906,5.853,2.899,8.916,4.088c2.311,0.897,4.728,1.903,6.799,2.995c1.963,1.036,3.902,3.257,5.921,4.206c-2.742,1.363-8.363,3.684-11.745,3.556c-1.226-0.047-1.769-0.463-3.103-0.333c-1.995,0.195-3.461,0.956-5.506,0.78c3.402,1.388,8.062,0.741,10.97,3.062c2.256,1.8,2.247,4.787,5.378,5.921c2.095,0.758,4.279,0.754,6.477,1.388c1.771,0.512,3.354,0.634,5.062,1.057c1.856,0.458,1.959,1.229,2.508,2.864c-0.933,0.627-2.056,0.844-3.046,1.4c-1.701,0.958-2.596,2.857-4.1,3.766c-2.162,1.306-6.182,2.48-8.712,2.148c-3.652-0.479-6.491,0.374-10.233,0.496c-2.258,0.075-4.304,1.029-6.563,1.107c1.459,1.327,2.812,2.674,4.452,3.811c1.666,1.155,3.636,1.812,5.079,3.412c-0.984,2.847-8.668,1.344-10.879,0.849c-1.995-0.448-3.829-0.442-5.926-0.451c-3.283-0.015-5.539-0.708-8.729-1.309c-9.681-1.825-16.693-10.305-27.197-8.89c-0.019,0.789,0.374,1.167,0.973,1.464L106.451,177.728z"/>
        </svg>
    </footer>

    <script>
        // Error handling utilities
        function showError(message) {
            const errorBanner = document.getElementById('error-banner');
            errorBanner.textContent = message;
            errorBanner.style.display = 'block';
            setTimeout(() => {
                errorBanner.style.display = 'none';
            }, 5000);
        }

        function hideError() {
            const errorBanner = document.getElementById('error-banner');
            errorBanner.style.display = 'none';
        }

        // Fetch with error handling
        async function fetchWithErrorHandling(url) {
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                return await res.json();
            } catch (err) {
                showError(`Failed to load data: ${err.message}`);
                return null;
            }
        }

        let expandedRequests = new Set();
        let detailViewMode = {}; // Track view mode per request: 'conversation' or 'json'

        // Table sorting state: { tableId: { column: index, direction: 'asc'|'desc'|null, originalData: [] } }
        let tableSortState = {};

        // Extract text from content (handles both string and multimodal array formats)
        function extractContentText(content) {
            if (!content) return '';

            // If content is a string, return as-is
            if (typeof content === 'string') {
                return content;
            }

            // If content is an array (multimodal format), extract text parts
            if (Array.isArray(content)) {
                return content.map(part => {
                    if (typeof part === 'string') return part;
                    if (part.type === 'text' && part.text) return part.text;
                    if (part.type === 'image_url') return '[Image]';
                    return '';
                }).filter(Boolean).join('\n\n');
            }

            // Fallback for unexpected formats
            return String(content);
        }

        // Extract conversation messages from request/response
        function extractConversation(requestObj) {
            try {
                const request = JSON.parse(requestObj.request_data);
                const response = JSON.parse(requestObj.response_data);

                const messages = [];

                // Extract request messages
                if (request.messages && Array.isArray(request.messages)) {
                    request.messages.forEach(msg => {
                        messages.push({
                            role: msg.role,
                            content: extractContentText(msg.content),
                            isRequest: true
                        });
                    });
                }

                // Extract response message
                if (response.choices && response.choices[0] && response.choices[0].message) {
                    const assistantMsg = response.choices[0].message;
                    messages.push({
                        role: assistantMsg.role || 'assistant',
                        content: extractContentText(assistantMsg.content),
                        isRequest: false
                    });
                }

                return messages;
            } catch (e) {
                return null;
            }
        }

        // Estimate token count for a message (rough approximation)
        function estimateTokens(text) {
            if (!text) return 0;
            // Rough estimate: ~4 characters per token
            return Math.ceil(text.length / 4);
        }

        // Format message content with markdown-like code block detection
        function formatMessageContent(content) {
            if (!content) return '';

            // Escape HTML
            const escaped = escapeHtml(content);

            // Convert markdown code blocks to HTML
            let formatted = escaped.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
                return `<pre><code>${code.trim()}</code></pre>`;
            });

            // Convert inline code
            formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');

            return formatted;
        }

        // Copy text to clipboard
        function copyToClipboard(text, button) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Render conversation view
        function renderConversationView(requestObj) {
            const messages = extractConversation(requestObj);
            if (!messages) {
                return '<p class="error">Could not extract conversation from request/response data</p>';
            }

            let html = '<div class="conversation-view">';

            messages.forEach((msg, index) => {
                const icon = msg.role === 'user' ? '⊙' : msg.role === 'assistant' ? '◈' : '⚙';
                const roleLabel = msg.role.charAt(0).toUpperCase() + msg.role.slice(1);
                const tokens = estimateTokens(msg.content);
                const formattedContent = formatMessageContent(msg.content);

                html += `
                    <div class="message">
                        <div class="message-icon">${icon}</div>
                        <div class="message-content">
                            <div class="message-header">
                                <div>
                                    <span class="message-role">${roleLabel}</span>
                                    <span class="message-meta">~${tokens.toLocaleString()} tokens</span>
                                </div>
                                <button class="copy-btn" onclick="copyToClipboard(\`${escapeHtml(msg.content).replace(/`/g, '\\`')}\`, this)">Copy</button>
                            </div>
                            <div class="message-text">${formattedContent}</div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            return html;
        }

        // Toggle between conversation and JSON view
        function toggleDetailView(requestId, mode) {
            detailViewMode[requestId] = mode;
            const requestObj = requestsObjects.find(r => r.timestamp === requestId);
            if (!requestObj) return;

            const detailRow = document.getElementById('detail-' + requestId);
            const contentDiv = detailRow.querySelector('.detail-content');

            if (mode === 'conversation') {
                contentDiv.innerHTML = renderConversationView(requestObj);
            } else {
                // JSON view
                let requestHtml = '<span class="error">Error parsing request</span>';
                let responseHtml = '<span class="error">Error parsing response</span>';

                try {
                    const req = JSON.parse(requestObj.request_data);
                    requestHtml = renderJsonTree(req);
                } catch(e) {}

                try {
                    const resp = JSON.parse(requestObj.response_data);
                    responseHtml = renderJsonTree(resp);
                } catch(e) {}

                contentDiv.innerHTML = `
                    <b>Request:</b>
                    <div class="json-view json-tree">${requestHtml}</div>
                    <b>Response:</b>
                    <div class="json-view json-tree">${responseHtml}</div>
                `;
            }

            // Update toggle buttons
            detailRow.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                }
            });
        }

        function sortTable(tableId, columnIndex, data, renderCallback) {
            if (!tableSortState[tableId]) {
                tableSortState[tableId] = { column: null, direction: null, originalData: [...data] };
            }

            const state = tableSortState[tableId];

            // Cycle through: null -> asc -> desc -> null
            if (state.column === columnIndex) {
                if (state.direction === 'asc') {
                    state.direction = 'desc';
                } else if (state.direction === 'desc') {
                    state.direction = null;
                    state.column = null;
                } else {
                    state.direction = 'asc';
                }
            } else {
                state.column = columnIndex;
                state.direction = 'asc';
            }

            let sortedData;
            if (state.direction === null) {
                // Return to original order
                sortedData = [...state.originalData];
            } else {
                sortedData = [...data].sort((a, b) => {
                    let aVal = a[columnIndex];
                    let bVal = b[columnIndex];

                    // Handle null/undefined
                    if (aVal == null) return state.direction === 'asc' ? 1 : -1;
                    if (bVal == null) return state.direction === 'asc' ? -1 : 1;

                    // Detect type and compare
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return state.direction === 'asc' ? aVal - bVal : bVal - aVal;
                    }

                    // String comparison (case-insensitive)
                    const aStr = String(aVal).toLowerCase();
                    const bStr = String(bVal).toLowerCase();
                    const comparison = aStr.localeCompare(bStr);
                    return state.direction === 'asc' ? comparison : -comparison;
                });
            }

            renderCallback(sortedData, state);
        }

        function makeSortableHeader(tableId, headers, onSort) {
            return headers.map((header, i) =>
                `<th class="sortable" onclick="${onSort}(${i})">${header}</th>`
            ).join('');
        }

        function updateSortIndicators(tableElement, state) {
            const headers = tableElement.querySelectorAll('th.sortable');
            headers.forEach((th, i) => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (state && state.column === i) {
                    th.classList.add(state.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function applySortIfNeeded(tableId, data) {
            const state = tableSortState[tableId];
            if (!state || state.direction === null) {
                return data;
            }

            return [...data].sort((a, b) => {
                let aVal = a[state.column];
                let bVal = b[state.column];

                if (aVal == null) return state.direction === 'asc' ? 1 : -1;
                if (bVal == null) return state.direction === 'asc' ? -1 : 1;

                if (typeof aVal === 'number' && typeof bVal === 'number') {
                    return state.direction === 'asc' ? aVal - bVal : bVal - aVal;
                }

                const aStr = String(aVal).toLowerCase();
                const bStr = String(bVal).toLowerCase();
                const comparison = aStr.localeCompare(bStr);
                return state.direction === 'asc' ? comparison : -comparison;
            });
        }

        function onTabChange(tab) {
            if (tab === 'stats') refreshStats();
            if (tab === 'calendar') loadCalendar();
            if (tab === 'models') loadModels();
            if (tab === 'requests') loadRequests();
        }

        let modelsData = [];

        async function loadModels() {
            const res = await fetch('/models');
            const data = await res.json();

            // Convert to array format for sorting: [name, provider, litellm_model, input_cost, output_cost]
            modelsData = data.models.map(m => [
                m.name,
                m.provider,
                m.litellm_model,
                m.input_cost_per_million || 0,
                m.output_cost_per_million || 0
            ]);

            if (!tableSortState['models-list']) {
                tableSortState['models-list'] = { column: null, direction: null, originalData: [...modelsData] };
            } else {
                tableSortState['models-list'].originalData = [...modelsData];
            }
            renderModelsTable(applySortIfNeeded('models-list', modelsData), tableSortState['models-list']);
        }

        function sortModelsTable(columnIndex) {
            sortTable('models-list', columnIndex, modelsData, renderModelsTable);
        }

        function renderModelsTable(data, sortState) {
            const table = document.getElementById('models-list');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th class="sortable" onclick="sortModelsTable(0)">Name</th>
                        <th class="sortable" onclick="sortModelsTable(1)">Provider</th>
                        <th class="sortable" onclick="sortModelsTable(2)">LiteLLM Model</th>
                        <th class="sortable" onclick="sortModelsTable(3)">Input Cost/1M</th>
                        <th class="sortable" onclick="sortModelsTable(4)">Output Cost/1M</th>
                    </tr>
                </thead>
                <tbody>
                    ${data.map(row => `
                        <tr>
                            <td>${row[0]}</td>
                            <td>${row[1]}</td>
                            <td>${row[2]}</td>
                            <td>${row[3] ? '$' + row[3].toFixed(2) : 'N/A'}</td>
                            <td>${row[4] ? '$' + row[4].toFixed(2) : 'N/A'}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            updateSortIndicators(table, sortState);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function renderJsonTree(obj, isRoot = true) {
            if (obj === null) return '<span class="json-null">null</span>';
            if (obj === undefined) return '<span class="json-null">undefined</span>';

            const type = typeof obj;
            if (type === 'string') return `<span class="json-string">"${escapeHtml(obj)}"</span>`;
            if (type === 'number') return `<span class="json-number">${obj}</span>`;
            if (type === 'boolean') return `<span class="json-boolean">${obj}</span>`;

            if (Array.isArray(obj)) {
                if (obj.length === 0) return '<span>[]</span>';

                const id = 'json-' + Math.random().toString(36).substr(2, 9);
                let html = `<span class="json-toggle" onclick="toggleJson('${id}')">▼</span>[`;
                html += `<div id="${id}" class="json-line">`;
                obj.forEach((item, i) => {
                    html += renderJsonTree(item, false);
                    if (i < obj.length - 1) html += ',';
                    html += '<br>';
                });
                html += '</div>]';
                return html;
            }

            if (type === 'object') {
                const keys = Object.keys(obj);
                if (keys.length === 0) return '<span>{}</span>';

                const id = 'json-' + Math.random().toString(36).substr(2, 9);
                let html = `<span class="json-toggle" onclick="toggleJson('${id}')">▼</span>{`;
                html += `<div id="${id}" class="json-line">`;
                keys.forEach((key, i) => {
                    html += `<span class="json-key">"${escapeHtml(key)}"</span>: `;
                    html += renderJsonTree(obj[key], false);
                    if (i < keys.length - 1) html += ',';
                    html += '<br>';
                });
                html += '</div>}';
                return html;
            }

            return String(obj);
        }

        function toggleJson(id) {
            const el = document.getElementById(id);
            const toggle = el.previousElementSibling;
            if (el.classList.contains('json-collapsed')) {
                el.classList.remove('json-collapsed');
                toggle.textContent = '▼';
            } else {
                el.classList.add('json-collapsed');
                toggle.textContent = '▶';
            }
        }

        let requestsData = [];
        let requestsObjects = []; // Store original request objects for detail rows
        let serverAggregates = { total: 0, total_tokens: 0, total_cost: 0, avg_cost: 0 }; // Server-side aggregates

        async function loadRequests() {
            if (!alpineData) return;
            try {
                const query = alpineData.buildQuery(alpineData.dateFilter);
                const offset = (alpineData.currentPage - 1) * alpineData.itemsPerPage;
                let url = `/requests${query}${query ? '&' : '?'}offset=${offset}&limit=${alpineData.itemsPerPage}`;

                // Add filter parameters
                const filters = alpineData.requestFilters;
                if (filters.provider) {
                    url += `&provider=${encodeURIComponent(filters.provider)}`;
                }
                if (filters.model) {
                    url += `&model=${encodeURIComponent(filters.model)}`;
                }
                if (filters.minCost !== '' && filters.minCost !== null) {
                    url += `&min_cost=${filters.minCost}`;
                }
                if (filters.maxCost !== '' && filters.maxCost !== null) {
                    url += `&max_cost=${filters.maxCost}`;
                }
                if (filters.search) {
                    url += `&search=${encodeURIComponent(filters.search)}`;
                }

                const res = await fetch(url);
                const data = await res.json();

                // Store server-side aggregates for ALL matching requests
                serverAggregates = {
                    total: data.total,
                    total_tokens: data.total_tokens,
                    total_cost: data.total_cost,
                    avg_cost: data.avg_cost
                };

                // Store total for pagination
                alpineData.totalItems = data.total;

                // Store original objects and convert to array format for sorting
                requestsObjects = data.requests;
                requestsData = data.requests.map(r => [
                    new Date(r.timestamp + 'Z').getTime(), // For sorting by time
                    r.model,
                    r.total_tokens,
                    r.cost,
                    r.duration_ms,
                    r.timestamp // Store timestamp for detail row lookup
                ]);

                // Populate filter dropdowns from current page data
                populateFilterDropdowns();

                // Initialize or update sort state
                if (!tableSortState['requests-list']) {
                    tableSortState['requests-list'] = { column: null, direction: null, originalData: [...requestsData] };
                } else {
                    // Update originalData to match current filtered results
                    tableSortState['requests-list'].originalData = [...requestsData];
                }

                // Update summary and render table
                updateRequestSummary();
                renderRequestsTable(requestsData, tableSortState['requests-list']);
            } catch(e) {
                document.getElementById('requests-list').innerHTML = '<tr><td colspan="5">Error loading requests</td></tr>';
            }
        }

        function populateFilterDropdowns() {
            // Get unique providers from current page data
            const providers = [...new Set(requestsObjects.map(r => r.provider).filter(Boolean))].sort();
            const providerSelect = document.getElementById('filter-provider');
            const currentProvider = alpineData.requestFilters.provider;
            providerSelect.innerHTML = '<option value="">All</option>';
            providers.forEach(p => {
                const option = document.createElement('option');
                option.value = p;
                option.textContent = p;
                if (p === currentProvider) option.selected = true;
                providerSelect.appendChild(option);
            });

            // Get unique models from current page data
            const models = [...new Set(requestsObjects.map(r => r.model).filter(Boolean))].sort();
            const modelSelect = document.getElementById('filter-model');
            const currentModel = alpineData.requestFilters.model;
            modelSelect.innerHTML = '<option value="">All</option>';
            models.forEach(m => {
                const option = document.createElement('option');
                option.value = m;
                option.textContent = m;
                if (m === currentModel) option.selected = true;
                modelSelect.appendChild(option);
            });
        }


        function updateRequestSummary() {
            const summary = document.getElementById('request-summary');

            // Use server-side aggregates for ALL matching requests, not just paginated results
            if (serverAggregates.total === 0) {
                summary.style.display = 'none';
                return;
            }

            document.getElementById('summary-count').textContent = serverAggregates.total.toLocaleString();
            document.getElementById('summary-cost').textContent = '$' + serverAggregates.total_cost.toFixed(4);
            document.getElementById('summary-tokens').textContent = serverAggregates.total_tokens.toLocaleString();
            document.getElementById('summary-avg-cost').textContent = '$' + serverAggregates.avg_cost.toFixed(4);

            summary.style.display = 'flex';
        }

        function sortRequestsTable(columnIndex) {
            sortTable('requests-list', columnIndex, requestsData, renderRequestsTable);
        }

        function renderRequestsTable(data, sortState) {
            const tbody = document.createElement('tbody');

            data.forEach(row => {
                const timestamp = row[5];
                const requestObj = requestsObjects.find(r => r.timestamp === timestamp);
                if (!requestObj) return;

                const requestId = timestamp;
                const currentMode = detailViewMode[requestId] || 'conversation';

                // Calculate cost breakdown
                const promptTokens = requestObj.prompt_tokens || 0;
                const completionTokens = requestObj.completion_tokens || 0;
                const totalTokens = requestObj.total_tokens || 0;
                const cost = requestObj.cost || 0;

                // Rough cost split based on token counts (not exact but reasonable)
                const promptCost = totalTokens > 0 ? (promptTokens / totalTokens) * cost : 0;
                const completionCost = cost - promptCost;

                // Create main row
                const mainRow = document.createElement('tr');
                mainRow.className = 'request-row';
                mainRow.onclick = () => toggleDetail(requestId);
                mainRow.innerHTML = `
                    <td>${escapeHtml(new Date(timestamp + 'Z').toLocaleString())}</td>
                    <td>${escapeHtml(row[1])}</td>
                    <td>${row[2].toLocaleString()}</td>
                    <td>$${row[3].toFixed(4)}</td>
                    <td>${row[4]}ms</td>
                `;

                // Create detail row, restore expanded state
                const detailRow = document.createElement('tr');
                detailRow.id = 'detail-' + requestId;
                detailRow.style.display = expandedRequests.has(requestId) ? 'table-row' : 'none';

                // Extract parameters from request data
                let paramsHtml = '';
                try {
                    const req = JSON.parse(requestObj.request_data);
                    const params = [];

                    if (req.temperature !== null && req.temperature !== undefined) {
                        params.push(`temp: ${req.temperature}`);
                    }
                    if (req.max_tokens !== null && req.max_tokens !== undefined) {
                        params.push(`max: ${req.max_tokens}`);
                    }
                    if (req.timeout !== null && req.timeout !== undefined) {
                        params.push(`timeout: ${req.timeout}s`);
                    }
                    if (req.num_retries !== null && req.num_retries !== undefined) {
                        params.push(`retries: ${req.num_retries}`);
                    }
                    if (req.top_p !== null && req.top_p !== undefined) {
                        params.push(`top_p: ${req.top_p}`);
                    }

                    if (params.length > 0) {
                        paramsHtml = `
                            <div class="detail-stat">
                                <span class="detail-stat-label">Params: </span>
                                <span class="detail-stat-value">${params.join(', ')}</span>
                            </div>
                        `;
                    }
                } catch(e) {
                    // Ignore parsing errors
                }

                // Build detail content
                const detailHeader = `
                    <div class="detail-header">
                        <div class="detail-stats">
                            <div class="detail-stat">
                                <span class="detail-stat-label">Model: </span>
                                <span class="detail-stat-value">${escapeHtml(requestObj.model)}</span>
                            </div>
                            <div class="detail-stat">
                                <span class="detail-stat-label">Provider: </span>
                                <span class="detail-stat-value">${escapeHtml(requestObj.provider || 'unknown')}</span>
                            </div>
                            <div class="detail-stat">
                                <span class="detail-stat-label">Tokens: </span>
                                <span class="detail-stat-value">${promptTokens.toLocaleString()} in / ${completionTokens.toLocaleString()} out = ${totalTokens.toLocaleString()} total</span>
                            </div>
                            <div class="detail-stat">
                                <span class="detail-stat-label">Cost: </span>
                                <span class="detail-stat-value">$${cost.toFixed(4)} ($${promptCost.toFixed(4)} in + $${completionCost.toFixed(4)} out)</span>
                            </div>
                            <div class="detail-stat">
                                <span class="detail-stat-label">Duration: </span>
                                <span class="detail-stat-value">${requestObj.duration_ms}ms</span>
                            </div>
                            ${paramsHtml}
                        </div>
                    </div>
                `;

                const toggleButtons = `
                    <div class="detail-toggle">
                        <button class="toggle-btn ${currentMode === 'conversation' ? 'active' : ''}" data-mode="conversation" onclick="event.stopPropagation(); toggleDetailView('${requestId}', 'conversation')">Conversation</button>
                        <button class="toggle-btn ${currentMode === 'json' ? 'active' : ''}" data-mode="json" onclick="event.stopPropagation(); toggleDetailView('${requestId}', 'json')">Raw JSON</button>
                    </div>
                `;

                // Generate initial content
                let contentHtml = '';
                if (currentMode === 'conversation') {
                    contentHtml = renderConversationView(requestObj);
                } else {
                    let requestHtml = '<span class="error">Error parsing request</span>';
                    let responseHtml = '<span class="error">Error parsing response</span>';

                    try {
                        const req = JSON.parse(requestObj.request_data);
                        requestHtml = renderJsonTree(req);
                    } catch(e) {}

                    try {
                        const resp = JSON.parse(requestObj.response_data);
                        responseHtml = renderJsonTree(resp);
                    } catch(e) {}

                    contentHtml = `
                        <b>Request:</b>
                        <div class="json-view json-tree">${requestHtml}</div>
                        <b>Response:</b>
                        <div class="json-view json-tree">${responseHtml}</div>
                    `;
                }

                detailRow.innerHTML = `
                    <td colspan="5" class="request-detail">
                        ${detailHeader}
                        ${toggleButtons}
                        <div class="detail-content">
                            ${contentHtml}
                        </div>
                    </td>
                `;

                tbody.appendChild(mainRow);
                tbody.appendChild(detailRow);
            });

            const table = document.getElementById('requests-list');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th class="sortable" onclick="sortRequestsTable(0)">Time</th>
                        <th class="sortable" onclick="sortRequestsTable(1)">Model</th>
                        <th class="sortable" onclick="sortRequestsTable(2)">Tokens</th>
                        <th class="sortable" onclick="sortRequestsTable(3)">Cost</th>
                        <th class="sortable" onclick="sortRequestsTable(4)">Duration</th>
                    </tr>
                </thead>
            `;
            table.appendChild(tbody);
            updateSortIndicators(table, sortState);
        }

        function toggleDetail(id) {
            const row = document.getElementById('detail-' + id);
            if (row) {
                const isHidden = row.style.display === 'none' || !row.style.display;
                row.style.display = isHidden ? 'table-row' : 'none';

                // Track expanded state
                if (isHidden) {
                    expandedRequests.add(id);
                } else {
                    expandedRequests.delete(id);
                }
            }
        }

        // Make Alpine data accessible to functions
        let alpineData = null;
        document.addEventListener('alpine:initialized', () => {
            alpineData = Alpine.$data(document.body);
            // Trigger initial data load now that Alpine is ready
            onTabChange(alpineData.currentTab || 'stats');
        });

        let byModelData = [];
        let byProviderData = [];
        let errorsData = [];

        // Provider trends chart state
        let hiddenProviders = new Set();

        // Provider colors (shared with bar chart)
        const PROVIDER_COLORS = {
            'openai': '#10a37f',
            'anthropic': '#d97757',
            'google': '#4285f4',
            'default': '#999999'
        };

        function getProviderColor(provider) {
            return PROVIDER_COLORS[provider] || PROVIDER_COLORS.default;
        }

        // Generate color tints for models within a provider
        function getModelColor(provider, modelIndex, totalModels) {
            const baseColor = getProviderColor(provider);

            // Parse hex color to RGB
            const r = parseInt(baseColor.slice(1, 3), 16);
            const g = parseInt(baseColor.slice(3, 5), 16);
            const b = parseInt(baseColor.slice(5, 7), 16);

            // Generate tint: darker for first model, lighter for subsequent
            // Lightness range: 0% (darkest) to 75% (lightest)
            const lightness = totalModels === 1 ? 0 : (modelIndex / (totalModels - 1)) * 0.75;

            // Mix with white to create tint
            const nr = Math.round(r + (255 - r) * lightness);
            const ng = Math.round(g + (255 - g) * lightness);
            const nb = Math.round(b + (255 - b) * lightness);

            return `#${nr.toString(16).padStart(2, '0')}${ng.toString(16).padStart(2, '0')}${nb.toString(16).padStart(2, '0')}`;
        }

        async function renderProviderTrends() {
            if (!alpineData) return;

            const container = document.getElementById('provider-trends-chart');
            const filter = alpineData.dateFilter;

            // Detect single-day view (Today, Yesterday, or custom single-day range)
            const isSingleDay = filter.startDate && filter.endDate && filter.startDate === filter.endDate;

            try {
                if (isSingleDay) {
                    // Fetch hourly data for single-day view
                    const timezoneOffset = -new Date().getTimezoneOffset();
                    const res = await fetch(`/stats/hourly?date=${filter.startDate}&timezone_offset=${timezoneOffset}`);
                    const data = await res.json();

                    if (!data.hourly || data.hourly.length === 0) {
                        container.innerHTML = '<div class="chart-empty">No data available for selected date</div>';
                        return;
                    }

                    renderHourlyChart(container, data.hourly, data.date);
                } else {
                    // Fetch daily data for multi-day view
                    const query = alpineData.buildQuery(filter);
                    const res = await fetch(`/stats/daily${query}`);
                    const data = await res.json();

                    if (!data.daily || data.daily.length === 0) {
                        container.innerHTML = '<div class="chart-empty">No data available for selected date range</div>';
                        return;
                    }

                    // Sort daily data by date ascending for proper line rendering
                    const dailyData = data.daily.sort((a, b) => a.date.localeCompare(b.date));

                    // Group data by model (includes provider for coloring)
                    const modelData = {};
                    dailyData.forEach(day => {
                        day.by_model.forEach(m => {
                            const modelKey = `${m.provider}:${m.model}`;
                            if (!modelData[modelKey]) {
                                modelData[modelKey] = {
                                    provider: m.provider,
                                    model: m.model,
                                    data: []
                                };
                            }
                            modelData[modelKey].data.push({
                                date: day.date,
                                cost: m.cost
                            });
                        });
                    });

                    // Fill in missing dates with 0 cost for each model
                    const allDates = dailyData.map(d => d.date);
                    Object.values(modelData).forEach(modelInfo => {
                        const existingDates = new Set(modelInfo.data.map(d => d.date));
                        allDates.forEach(date => {
                            if (!existingDates.has(date)) {
                                modelInfo.data.push({ date, cost: 0 });
                            }
                        });
                        // Re-sort after filling gaps
                        modelInfo.data.sort((a, b) => a.date.localeCompare(b.date));
                    });

                    // Sort models by total cost and assign colors
                    const sortedModels = Object.values(modelData).sort((a, b) => {
                        const aCost = a.data.reduce((sum, d) => sum + d.cost, 0);
                        const bCost = b.data.reduce((sum, d) => sum + d.cost, 0);
                        return bCost - aCost;
                    });

                    // Group by provider and assign colors
                    const modelsByProvider = {};
                    sortedModels.forEach(m => {
                        if (!modelsByProvider[m.provider]) {
                            modelsByProvider[m.provider] = [];
                        }
                        modelsByProvider[m.provider].push(m);
                    });

                    // Assign colors to models
                    Object.entries(modelsByProvider).forEach(([provider, models]) => {
                        models.forEach((m, index) => {
                            m.color = getModelColor(provider, index, models.length);
                        });
                    });

                    renderChart(container, sortedModels, allDates);
                }
            } catch (e) {
                console.error('Failed to load provider trends:', e);
                container.innerHTML = '<div class="chart-empty">Failed to load chart data</div>';
            }
        }

        function renderHourlyChart(container, hourlyData, date) {
            const width = container.offsetWidth - 40; // Account for padding
            const height = 300;
            const margin = { top: 20, right: 80, bottom: 60, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Calculate max cost for scaling
            const maxCost = Math.max(...hourlyData.map(h => h.cost), 0.0001);
            const minCost = 0;

            // Group data by model for stacked bars
            const modelTotals = {};
            hourlyData.forEach(hour => {
                hour.by_model.forEach(m => {
                    const modelKey = `${m.provider}:${m.model}`;
                    if (!modelTotals[modelKey]) {
                        modelTotals[modelKey] = {
                            provider: m.provider,
                            model: m.model,
                            costs: new Array(24).fill(0)
                        };
                    }
                    modelTotals[modelKey].costs[hour.hour] = m.cost;
                });
            });

            // Sort models by total cost and assign colors
            const sortedModels = Object.values(modelTotals).sort((a, b) => {
                const aCost = a.costs.reduce((sum, c) => sum + c, 0);
                const bCost = b.costs.reduce((sum, c) => sum + c, 0);
                return bCost - aCost;
            });

            // Group by provider and assign colors
            const modelsByProvider = {};
            sortedModels.forEach(m => {
                if (!modelsByProvider[m.provider]) {
                    modelsByProvider[m.provider] = [];
                }
                modelsByProvider[m.provider].push(m);
            });

            Object.entries(modelsByProvider).forEach(([provider, models]) => {
                models.forEach((m, index) => {
                    m.color = getModelColor(provider, index, models.length);
                });
            });
            const barWidth = chartWidth / 24;

            // Y scale: cost to pixel (inverted because SVG Y increases downward)
            const yScale = (cost) => chartHeight - ((cost - minCost) / (maxCost - minCost)) * chartHeight;

            // Format hour for display (0-23 to "12am", "1am", ... "11pm")
            const formatHour = (hour) => {
                if (hour === 0) return '12am';
                if (hour < 12) return hour + 'am';
                if (hour === 12) return '12pm';
                return (hour - 12) + 'pm';
            };

            // Create SVG
            let svg = `
                <svg class="chart-svg" viewBox="0 0 ${width} ${height + 40}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${margin.left}, ${margin.top})">
            `;

            // Add grid lines
            const gridSteps = 5;
            for (let i = 0; i <= gridSteps; i++) {
                const y = (i / gridSteps) * chartHeight;
                svg += `<line class="chart-grid" x1="0" y1="${y}" x2="${chartWidth}" y2="${y}" />`;
            }

            // Add Y axis
            svg += `<line class="chart-axis" x1="0" y1="0" x2="0" y2="${chartHeight}" />`;
            for (let i = 0; i <= gridSteps; i++) {
                const y = (i / gridSteps) * chartHeight;
                const cost = maxCost - (i / gridSteps) * (maxCost - minCost);
                svg += `<text class="chart-axis-text" x="-10" y="${y + 4}" text-anchor="end">$${cost.toFixed(3)}</text>`;
            }

            // Add X axis
            svg += `<line class="chart-axis" x1="0" y1="${chartHeight}" x2="${chartWidth}" y2="${chartHeight}" />`;

            // Add X axis labels (show every 3 hours to avoid crowding: 0, 3, 6, 9, 12, 15, 18, 21)
            for (let hour = 0; hour < 24; hour += 3) {
                const x = hour * barWidth + barWidth / 2;
                svg += `<text class="chart-axis-text" x="${x}" y="${chartHeight + 20}" text-anchor="middle">${formatHour(hour)}</text>`;
            }

            // Draw stacked bars for each hour
            for (let hour = 0; hour < 24; hour++) {
                const x = hour * barWidth;
                let yOffset = chartHeight;

                sortedModels.forEach(modelInfo => {
                    const cost = modelInfo.costs[hour];
                    if (cost > 0) {
                        const barHeight = chartHeight - yScale(cost);
                        yOffset -= barHeight;
                        svg += `<rect class="chart-bar" x="${x + 2}" y="${yOffset}" width="${barWidth - 4}" height="${barHeight}" fill="${modelInfo.color}" />`;
                    }
                });
            }

            // Add legend grouped by provider
            let legendY = 0;
            const legendX = chartWidth + 10;

            Object.entries(modelsByProvider).forEach(([provider, models]) => {
                // Add provider name
                svg += `<text class="chart-legend-text" x="${legendX}" y="${legendY + 8}" style="font-weight: bold;">${provider}</text>`;
                legendY += 18;

                // Add models for this provider
                models.forEach(m => {
                    svg += `
                        <circle cx="${legendX}" cy="${legendY + 4}" r="4" fill="${m.color}" />
                        <text class="chart-legend-text" x="${legendX + 10}" y="${legendY + 8}">${escapeHtml(m.model)}</text>
                    `;
                    legendY += 16;
                });

                legendY += 4; // Extra space between providers
            });

            svg += `
                    </g>
                </svg>
            `;

            // Display date as title
            const dateObj = new Date(date + 'T00:00:00');
            const dateStr = dateObj.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });

            container.innerHTML = `
                <div class="chart-title">Hourly Usage - ${dateStr}</div>
                ${svg}
            `;
        }

        function renderChart(container, modelData, dates) {
            // Need at least 3 data points for a meaningful trend chart
            if (dates.length < 3) {
                container.innerHTML = `
                    <div class="chart-empty">
                        <p>Not enough data for trends chart</p>
                        <p class="chart-empty-hint">Charts require at least 3 days of data. Keep using Apantli to see trends!</p>
                    </div>
                `;
                return;
            }

            const width = container.offsetWidth - 40; // Account for padding
            const height = 300;
            const margin = { top: 20, right: 80, bottom: 60, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Calculate scales
            const maxCost = Math.max(...modelData.flatMap(m => m.data.map(d => d.cost)), 0.0001);
            const minCost = 0;

            // X scale: date to pixel
            const xScale = (dateIndex) => (dateIndex / (dates.length - 1 || 1)) * chartWidth;

            // Y scale: cost to pixel (inverted because SVG Y increases downward)
            const yScale = (cost) => chartHeight - ((cost - minCost) / (maxCost - minCost)) * chartHeight;

            // Format date for display
            const formatDate = (dateStr) => {
                const date = new Date(dateStr);
                return `${date.getMonth() + 1}/${date.getDate()}`;
            };

            // Create SVG
            let svg = `
                <svg class="chart-svg" viewBox="0 0 ${width} ${height + 40}" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(${margin.left}, ${margin.top})">
            `;

            // Add grid lines
            const gridSteps = 5;
            for (let i = 0; i <= gridSteps; i++) {
                const y = (i / gridSteps) * chartHeight;
                svg += `<line class="chart-grid" x1="0" y1="${y}" x2="${chartWidth}" y2="${y}" />`;
            }

            // Add Y axis
            svg += `<line class="chart-axis" x1="0" y1="0" x2="0" y2="${chartHeight}" />`;
            for (let i = 0; i <= gridSteps; i++) {
                const y = (i / gridSteps) * chartHeight;
                const cost = maxCost - (i / gridSteps) * (maxCost - minCost);
                svg += `<text class="chart-axis-text" x="-10" y="${y + 4}" text-anchor="end">$${cost.toFixed(3)}</text>`;
            }

            // Add X axis
            svg += `<line class="chart-axis" x1="0" y1="${chartHeight}" x2="${chartWidth}" y2="${chartHeight}" />`;

            // Add X axis labels (show fewer labels to avoid crowding)
            const labelStep = Math.ceil(dates.length / 8);
            dates.forEach((date, i) => {
                if (i % labelStep === 0 || i === dates.length - 1) {
                    const x = xScale(i);
                    svg += `<text class="chart-axis-text" x="${x}" y="${chartHeight + 20}" text-anchor="middle">${formatDate(date)}</text>`;
                }
            });

            // Draw lines for each model
            modelData.forEach(modelInfo => {
                const color = modelInfo.color;

                // Generate path
                const pathData = modelInfo.data.map((d, i) => {
                    const x = xScale(i);
                    const y = yScale(d.cost);
                    return `${i === 0 ? 'M' : 'L'} ${x} ${y}`;
                }).join(' ');

                svg += `<path class="chart-line" d="${pathData}" stroke="${color}" />`;

                // Add dots
                modelInfo.data.forEach((d, i) => {
                    if (d.cost > 0) {
                        const x = xScale(i);
                        const y = yScale(d.cost);
                        const modelLabel = escapeHtml(modelInfo.model);
                        svg += `
                            <circle class="chart-dot" cx="${x}" cy="${y}" r="3" stroke="${color}"
                                    onmouseover="showChartTooltip(event, '${d.date}', '${modelLabel}', ${d.cost})"
                                    onmouseout="hideChartTooltip()" />
                        `;
                    }
                });
            });

            svg += `
                    </g>
                </svg>
            `;

            // Add legend grouped by provider
            const modelsByProvider = {};
            modelData.forEach(m => {
                if (!modelsByProvider[m.provider]) {
                    modelsByProvider[m.provider] = [];
                }
                modelsByProvider[m.provider].push(m);
            });

            let legend = '';
            Object.entries(modelsByProvider).forEach(([provider, models]) => {
                // Add provider header
                legend += `<div style="width: 100%; font-weight: bold; margin-top: 8px; color: var(--color-text);">${provider}</div>`;

                // Add models for this provider
                models.forEach(m => {
                    const totalCost = m.data.reduce((sum, d) => sum + d.cost, 0);
                    legend += `
                        <div class="chart-legend-item">
                            <div class="chart-legend-color" style="background: ${m.color}"></div>
                            <div class="chart-legend-label">${escapeHtml(m.model)} ($${totalCost.toFixed(4)})</div>
                        </div>
                    `;
                });
            });

            container.innerHTML = svg + `<div class="chart-legend">${legend}</div>`;
        }

        function showChartTooltip(event, date, provider, cost) {
            const tooltip = document.getElementById('chart-tooltip');
            tooltip.innerHTML = `
                <div class="chart-tooltip-date">${date}</div>
                <div class="chart-tooltip-item">
                    <span>${provider}:</span>
                    <span>$${cost.toFixed(4)}</span>
                </div>
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 30) + 'px';
        }

        function hideChartTooltip() {
            const tooltip = document.getElementById('chart-tooltip');
            tooltip.style.display = 'none';
        }

        function toggleProvider(provider) {
            if (hiddenProviders.has(provider)) {
                hiddenProviders.delete(provider);
            } else {
                hiddenProviders.add(provider);
            }
            renderProviderTrends();
        }

        async function refreshStats() {
            if (!alpineData) return;
            const query = alpineData.buildQuery(alpineData.dateFilter);

            // Fetch stats and daily data in parallel for faster loading
            const [statsRes, _] = await Promise.all([
                fetch(`/stats${query}`),
                renderProviderTrends() // Start chart fetch in parallel
            ]);
            const data = await statsRes.json();

            // Totals
            document.getElementById('totals').innerHTML = `
                <div class="metric">
                    <div class="metric-value">${data.totals.requests}</div>
                    <div class="metric-label">REQUESTS</div>
                </div>
                <div class="metric">
                    <div class="metric-value">$${data.totals.cost.toFixed(4)}</div>
                    <div class="metric-label">TOTAL COST</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${(data.totals.prompt_tokens + data.totals.completion_tokens).toLocaleString()}</div>
                    <div class="metric-label">TOTAL TOKENS</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${data.totals.avg_duration_ms.toFixed(0)}ms</div>
                    <div class="metric-label">AVG DURATION</div>
                </div>
            `;

            // Provider breakdown visualization with model segments
            const totalCost = data.totals.cost;

            let providerHtml = '';
            if (data.by_model.length > 0 && totalCost > 0) {
                // Group models by provider
                const modelsByProvider = {};
                data.by_model.forEach(m => {
                    if (!modelsByProvider[m.provider]) {
                        modelsByProvider[m.provider] = [];
                    }
                    modelsByProvider[m.provider].push(m);
                });

                // Sort providers by total cost
                const providerTotals = Object.entries(modelsByProvider).map(([provider, models]) => ({
                    provider,
                    models,
                    totalCost: models.reduce((sum, m) => sum + m.cost, 0),
                    totalRequests: models.reduce((sum, m) => sum + m.requests, 0)
                })).sort((a, b) => b.totalCost - a.totalCost);

                providerHtml = providerTotals.map(p => {
                    const providerPercentage = (p.totalCost / totalCost * 100);

                    // Sort models by cost within provider and assign colors
                    const sortedModels = p.models.sort((a, b) => b.cost - a.cost);
                    sortedModels.forEach((m, index) => {
                        m.color = getModelColor(p.provider, index, sortedModels.length);
                    });

                    // Create segmented bar
                    const segments = sortedModels.map(m => {
                        const modelPercentage = (m.cost / totalCost * 100);
                        const modelLabel = escapeHtml(m.model);
                        return `<div class="bar-segment" style="width: ${modelPercentage}%; background: ${m.color}; cursor: pointer;"
                                     onmouseover="showChartTooltip(event, '${p.provider}', '${modelLabel}', ${m.cost})"
                                     onmouseout="hideChartTooltip()"></div>`;
                    }).join('');

                    // Model details list
                    const modelDetails = sortedModels.map(m =>
                        `<span style="color: ${m.color};">●</span> ${escapeHtml(m.model)}: $${m.cost.toFixed(4)} (${m.requests} req)`
                    ).join(' • ');

                    return `
                        <div class="provider-bar">
                            <div class="provider-header">
                                <span class="provider-name">${p.provider}</span>
                                <span class="provider-percentage">${providerPercentage.toFixed(0)}%</span>
                            </div>
                            <div class="bar-container">
                                ${segments}
                            </div>
                            <div class="provider-details">
                                $${p.totalCost.toFixed(4)} across ${p.totalRequests} requests ($${(p.totalCost / p.totalRequests).toFixed(4)} per request)
                            </div>
                            <div class="provider-details" style="font-size: 11px; margin-top: 4px;">
                                ${modelDetails}
                            </div>
                        </div>
                    `;
                }).join('');

                providerHtml += `<div style="margin-top: 20px; font-weight: bold;">Total: $${totalCost.toFixed(4)} (${data.totals.requests} requests)</div>`;
            } else {
                providerHtml = '<div style="color: #666;">No data available</div>';
            }

            document.getElementById('provider-breakdown').innerHTML = providerHtml;

            // By model - convert to sortable format
            byModelData = data.by_model.map(m => [m.model, m.requests, m.cost, m.tokens]);
            if (!tableSortState['by-model']) {
                tableSortState['by-model'] = { column: null, direction: null, originalData: [...byModelData] };
            } else {
                tableSortState['by-model'].originalData = [...byModelData];
            }
            renderByModelTable(applySortIfNeeded('by-model', byModelData), tableSortState['by-model']);

            // Model efficiency
            renderModelEfficiency(byModelData);

            // Model performance (speed)
            renderModelPerformance(data.performance || []);

            // By provider - convert to sortable format
            byProviderData = data.by_provider.map(p => [p.provider, p.requests, p.cost, p.tokens]);
            if (!tableSortState['by-provider']) {
                tableSortState['by-provider'] = { column: null, direction: null, originalData: [...byProviderData] };
            } else {
                tableSortState['by-provider'].originalData = [...byProviderData];
            }
            renderByProviderTable(applySortIfNeeded('by-provider', byProviderData), tableSortState['by-provider']);

            // Errors - convert to sortable format
            errorsData = data.recent_errors.map(e => [new Date(e.timestamp + 'Z').getTime(), e.model, e.error, e.timestamp]);
            if (!tableSortState['errors']) {
                tableSortState['errors'] = { column: null, direction: null, originalData: [...errorsData] };
            } else {
                tableSortState['errors'].originalData = [...errorsData];
            }
            renderErrorsTable(applySortIfNeeded('errors', errorsData), tableSortState['errors']);
        }

        function sortByModelTable(columnIndex) {
            sortTable('by-model', columnIndex, byModelData, renderByModelTable);
        }

        function renderByModelTable(data, sortState) {
            const table = document.getElementById('by-model');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th class="sortable" onclick="sortByModelTable(0)">Model</th>
                        <th class="sortable" onclick="sortByModelTable(1)">Requests</th>
                        <th class="sortable" onclick="sortByModelTable(2)">Cost</th>
                        <th class="sortable" onclick="sortByModelTable(3)">Tokens</th>
                    </tr>
                </thead>
                <tbody>
                    ${data.map(row => `
                        <tr>
                            <td>${row[0]}</td>
                            <td>${row[1]}</td>
                            <td>$${row[2].toFixed(4)}</td>
                            <td>${row[3].toLocaleString()}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            updateSortIndicators(table, sortState);
        }

        function renderModelEfficiency(modelData) {
            const container = document.getElementById('model-efficiency');

            if (!modelData || modelData.length === 0) {
                container.innerHTML = '<div class="chart-empty">No model data available</div>';
                return;
            }

            // Calculate efficiency metrics
            const efficiencyData = modelData.map(row => ({
                model: row[0],
                requests: row[1],
                cost: row[2],
                tokens: row[3],
                avgCostPerRequest: row[2] / row[1],
                avgTokensPerRequest: row[3] / row[1]
            }));

            // Find most economical (lowest avg cost)
            const mostEconomical = efficiencyData.reduce((min, curr) =>
                curr.avgCostPerRequest < min.avgCostPerRequest ? curr : min
            );

            // Find most token-rich (highest avg tokens)
            const mostTokenRich = efficiencyData.reduce((max, curr) =>
                curr.avgTokensPerRequest > max.avgTokensPerRequest ? curr : max
            );

            // Render efficiency cards
            const cards = efficiencyData.map(data => {
                const isEconomical = data.model === mostEconomical.model;
                const isTokenRich = data.model === mostTokenRich.model;
                const highlightClass = isEconomical ? 'highlight-economical' : (isTokenRich ? 'highlight-tokens' : '');

                return `
                    <div class="efficiency-card ${highlightClass}">
                        <div class="efficiency-model-name">
                            ${data.model}
                            ${isEconomical ? '<span class="efficiency-badge economical">Most Economical</span>' : ''}
                            ${isTokenRich ? '<span class="efficiency-badge token-rich">Most Token-Rich</span>' : ''}
                        </div>
                        <div class="efficiency-metrics">
                            <div class="efficiency-metric">
                                <div class="efficiency-metric-label">Avg Cost/Request</div>
                                <div class="efficiency-metric-value">$${data.avgCostPerRequest.toFixed(4)}</div>
                            </div>
                            <div class="efficiency-metric">
                                <div class="efficiency-metric-label">Avg Tokens/Request</div>
                                <div class="efficiency-metric-value">${Math.round(data.avgTokensPerRequest).toLocaleString()}</div>
                            </div>
                            <div class="efficiency-metric">
                                <div class="efficiency-metric-label">Total Requests</div>
                                <div class="efficiency-metric-value">${data.requests.toLocaleString()}</div>
                            </div>
                            <div class="efficiency-metric">
                                <div class="efficiency-metric-label">Total Cost</div>
                                <div class="efficiency-metric-value">$${data.cost.toFixed(4)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="efficiency-grid">
                    ${cards}
                </div>
                <div class="efficiency-summary">
                    Most economical: <strong>${mostEconomical.model}</strong> at $${mostEconomical.avgCostPerRequest.toFixed(4)}/request
                    &nbsp;•&nbsp;
                    Most token-rich: <strong>${mostTokenRich.model}</strong> at ${Math.round(mostTokenRich.avgTokensPerRequest).toLocaleString()} tokens/request
                </div>
            `;
        }

        function renderModelPerformance(performanceData) {
            const container = document.getElementById('model-performance');

            if (!performanceData || performanceData.length === 0) {
                container.innerHTML = '<div class="chart-empty">No performance data available (requires requests with completion tokens)</div>';
                return;
            }

            // Find fastest model
            const fastest = performanceData.reduce((max, curr) =>
                curr.avg_tokens_per_sec > max.avg_tokens_per_sec ? curr : max
            );

            // Render performance cards
            const cards = performanceData.map(data => {
                const isFastest = data.model === fastest.model;
                const highlightClass = isFastest ? 'highlight-tokens' : '';

                return `
                    <div class="efficiency-card ${highlightClass}">
                        <div class="efficiency-model-name">
                            ${data.model}
                            ${isFastest ? '<span class="efficiency-badge token-rich">Fastest</span>' : ''}
                        </div>
                        <div class="efficiency-metrics">
                            <div class="efficiency-metric">
                                <div class="efficiency-metric-label">Avg Speed</div>
                                <div class="efficiency-metric-value">${data.avg_tokens_per_sec.toFixed(1)} tok/s</div>
                            </div>
                            <div class="efficiency-metric">
                                <div class="efficiency-metric-label">Speed Range</div>
                                <div class="efficiency-metric-value">${data.min_tokens_per_sec.toFixed(1)} - ${data.max_tokens_per_sec.toFixed(1)}</div>
                            </div>
                            <div class="efficiency-metric">
                                <div class="efficiency-metric-label">Avg Duration</div>
                                <div class="efficiency-metric-value">${Math.round(data.avg_duration_ms)}ms</div>
                            </div>
                            <div class="efficiency-metric">
                                <div class="efficiency-metric-label">Requests Measured</div>
                                <div class="efficiency-metric-value">${data.requests.toLocaleString()}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="efficiency-grid">
                    ${cards}
                </div>
                <div class="efficiency-summary">
                    Fastest: <strong>${fastest.model}</strong> at ${fastest.avg_tokens_per_sec.toFixed(1)} tokens/second
                    &nbsp;•&nbsp;
                    Note: Duration includes network latency and prompt processing time
                </div>
            `;
        }

        function sortByProviderTable(columnIndex) {
            sortTable('by-provider', columnIndex, byProviderData, renderByProviderTable);
        }

        function renderByProviderTable(data, sortState) {
            const table = document.getElementById('by-provider');
            table.innerHTML = `
                <thead>
                    <tr>
                        <th class="sortable" onclick="sortByProviderTable(0)">Provider</th>
                        <th class="sortable" onclick="sortByProviderTable(1)">Requests</th>
                        <th class="sortable" onclick="sortByProviderTable(2)">Cost</th>
                        <th class="sortable" onclick="sortByProviderTable(3)">Tokens</th>
                    </tr>
                </thead>
                <tbody>
                    ${data.map(row => `
                        <tr>
                            <td>${row[0]}</td>
                            <td>${row[1]}</td>
                            <td>$${row[2].toFixed(4)}</td>
                            <td>${row[3].toLocaleString()}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            updateSortIndicators(table, sortState);
        }

        function sortErrorsTable(columnIndex) {
            sortTable('errors', columnIndex, errorsData, renderErrorsTable);
        }

        function renderErrorsTable(data, sortState) {
            const table = document.getElementById('errors');
            if (data.length === 0) {
                table.innerHTML = '<tr><td>No errors</td></tr>';
                return;
            }

            table.innerHTML = `
                <thead>
                    <tr>
                        <th class="sortable" onclick="sortErrorsTable(0)">Time</th>
                        <th class="sortable" onclick="sortErrorsTable(1)">Model</th>
                        <th class="sortable" onclick="sortErrorsTable(2)">Error</th>
                    </tr>
                </thead>
                <tbody>
                    ${data.map(row => `
                        <tr>
                            <td>${new Date(row[3] + 'Z').toLocaleString()}</td>
                            <td>${row[1]}</td>
                            <td class="error">${row[2]}</td>
                        </tr>
                    `).join('')}
                </tbody>
            `;
            updateSortIndicators(table, sortState);
        }

        async function clearErrors() {
            if (!confirm('Clear all errors from the database?')) return;
            await fetch('/errors', { method: 'DELETE' });
            refreshStats();
        }

        // Calendar functionality
        let currentMonth = new Date();
        let selectedDate = null;
        let calendarData = {};

        function getCostColor(cost, maxCost) {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';

            if (cost === 0) {
                return isDark ? '#2a2a2a' : '#f0f0f0';
            }

            const ratio = Math.min(cost / (maxCost || 1), 1);

            if (isDark) {
                // Dark mode: darker blues with less saturation
                const lightness = 25 + (ratio * 25); // 25% to 50%
                const saturation = 60 + (ratio * 20); // 60% to 80%
                return `hsl(210, ${saturation}%, ${lightness}%)`;
            } else {
                // Light mode: lighter blues
                const lightness = 100 - (ratio * 50); // 100% to 50%
                return `hsl(210, 100%, ${lightness}%)`;
            }
        }

        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        async function loadCalendar() {
            const year = currentMonth.getFullYear();
            const month = currentMonth.getMonth();

            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);

            const startDate = formatDate(firstDay);
            const endDate = formatDate(lastDay);

            // Get browser timezone offset in minutes from UTC (negative for west)
            const timezoneOffset = -new Date().getTimezoneOffset();

            const res = await fetch(`/stats/daily?start_date=${startDate}&end_date=${endDate}&timezone_offset=${timezoneOffset}`);
            const data = await res.json();

            calendarData = {};
            data.daily.forEach(day => {
                calendarData[day.date] = day;
            });

            renderCalendar(year, month);
        }

        function renderCalendar(year, month) {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            document.getElementById('current-month').textContent = `${monthNames[month]} ${year}`;

            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startingDayOfWeek = firstDay.getDay();
            const daysInMonth = lastDay.getDate();

            const today = formatDate(new Date());
            const maxCost = Math.max(...Object.values(calendarData).map(d => d.cost), 0.01);

            let html = '';
            ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].forEach(day => {
                html += `<div class="calendar-day-header">${day}</div>`;
            });

            for (let i = 0; i < startingDayOfWeek; i++) {
                html += '<div class="calendar-day empty"></div>';
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const date = formatDate(new Date(year, month, day));
                const dayData = calendarData[date] || { requests: 0, cost: 0 };
                const bgColor = getCostColor(dayData.cost, maxCost);
                const isToday = date === today ? 'today' : '';

                const ariaLabel = `${date}: ${dayData.requests} requests, $${dayData.cost.toFixed(2)} total cost`;
                html += `
                    <div class="calendar-day ${isToday}"
                         style="background-color: ${bgColor}"
                         onclick="onDayClick('${date}')"
                         onkeydown="handleCalendarKeyPress(event, '${date}')"
                         tabindex="0"
                         role="gridcell"
                         aria-label="${ariaLabel}"
                         data-date="${date}">
                        <div class="day-number">${day}</div>
                        <div class="day-cost">$${dayData.cost.toFixed(2)}</div>
                        <div class="day-requests">${dayData.requests} req</div>
                    </div>
                `;
            }

            document.getElementById('calendar-grid').innerHTML = html;
        }

        function navigateMonth(direction) {
            currentMonth = new Date(currentMonth.getFullYear(), currentMonth.getMonth() + direction, 1);
            loadCalendar();
        }

        function handleCalendarKeyPress(event, date) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                onDayClick(date);
            }
        }

        function onDayClick(date) {
            selectedDate = date;
            const dayData = calendarData[date];

            if (!dayData || dayData.requests === 0) {
                document.getElementById('day-detail').style.display = 'none';
                return;
            }

            const detailTitle = document.getElementById('day-detail-title');
            const detailContent = document.getElementById('day-detail-content');

            detailTitle.textContent = `${date} - $${dayData.cost.toFixed(4)} across ${dayData.requests} requests`;

            let providersHtml = '<h4>By Provider:</h4>';
            const totalCost = dayData.cost;

            dayData.by_provider.forEach(p => {
                const percentage = totalCost > 0 ? (p.cost / totalCost * 100) : 0;
                const color = getProviderColor(p.provider);

                providersHtml += `
                    <div class="provider-bar">
                        <div class="provider-header">
                            <span class="provider-name">${p.provider}</span>
                            <span class="provider-percentage">${percentage.toFixed(0)}%</span>
                        </div>
                        <div class="bar-container">
                            <div class="bar-fill" style="width: ${percentage}%; background: ${color}"></div>
                        </div>
                        <div class="provider-details">
                            $${p.cost.toFixed(4)} across ${p.requests} requests
                        </div>
                    </div>
                `;
            });

            detailContent.innerHTML = providersHtml;
            document.getElementById('day-detail').style.display = 'block';
        }

        // Auto-refresh stats every 5 seconds (uses current filter state)
        setInterval(() => {
            if (alpineData && alpineData.currentTab === 'stats') {
                refreshStats();
            }
        }, 5000);

        // Load initial tab data after Alpine initializes
        document.addEventListener('alpine:initialized', () => {
            const initialTab = localStorage.getItem('_x_currentTab')?.replace(/['"]/g, '') || 'stats';
            onTabChange(initialTab);
        });
    </script>
</body>
</html>
